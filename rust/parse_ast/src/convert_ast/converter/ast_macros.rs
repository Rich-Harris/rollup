// This file is generated by scripts/generate-ast-macros.js.
// Do not edit this file directly.

#[macro_export]
macro_rules! store_assignment_expression {
  ($self:expr, span => $span:expr, operator => $operator_value:expr, left => [$left_value:expr, $left_converter:ident], right => [$right_value:expr, $right_converter:ident]) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&5u32.to_ne_bytes(), &$span, 16, false);
    // operator
    let operator_position = end_position + 4;
    $self.buffer[operator_position..operator_position + 4].copy_from_slice($operator_value);
    // left
    $self.update_reference_position(end_position + 8);
    $self.$left_converter(&$left_value);
    // right
    $self.update_reference_position(end_position + 12);
    $self.$right_converter(&$right_value);
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_await_expression {
  ($self:expr, span => $span:expr, argument => [$argument_value:expr, $argument_converter:ident]) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&7u32.to_ne_bytes(), &$span, 8, false);
    // argument
    $self.update_reference_position(end_position + 4);
    $self.$argument_converter(&$argument_value);
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_break_statement {
  ($self:expr, span => $span:expr, label => [$label_value:expr, $label_converter:ident]) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&10u32.to_ne_bytes(), &$span, 8, false);
    // label
    if let Some(value) = $label_value.as_ref() {
      $self.update_reference_position(end_position + 4);
      $self.$label_converter(value);
    }
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_conditional_expression {
  ($self:expr, span => $span:expr, test => [$test_value:expr, $test_converter:ident], consequent => [$consequent_value:expr, $consequent_converter:ident], alternate => [$alternate_value:expr, $alternate_converter:ident]) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&17u32.to_ne_bytes(), &$span, 16, false);
    // test
    $self.update_reference_position(end_position + 4);
    $self.$test_converter(&$test_value);
    // consequent
    $self.update_reference_position(end_position + 8);
    $self.$consequent_converter(&$consequent_value);
    // alternate
    $self.update_reference_position(end_position + 12);
    $self.$alternate_converter(&$alternate_value);
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_continue_statement {
  ($self:expr, span => $span:expr, label => [$label_value:expr, $label_converter:ident]) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&18u32.to_ne_bytes(), &$span, 8, false);
    // label
    if let Some(value) = $label_value.as_ref() {
      $self.update_reference_position(end_position + 4);
      $self.$label_converter(value);
    }
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_debugger_statement {
  ($self:expr, span => $span:expr) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&19u32.to_ne_bytes(), &$span, 4, false);
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_directive {
  ($self:expr, span => $span:expr, directive => $directive_value:expr, expression => [$expression_value:expr, $expression_converter:ident]) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&20u32.to_ne_bytes(), &$span, 12, false);
    // directive
    $self.convert_string($directive_value, end_position + 4);
    // expression
    $self.update_reference_position(end_position + 8);
    $self.$expression_converter(&$expression_value);
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_empty_statement {
  ($self:expr, span => $span:expr) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&22u32.to_ne_bytes(), &$span, 4, false);
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_literal_number {
  ($self:expr, span => $span:expr, raw => $raw_value:expr, value => $value_value:expr) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&45u32.to_ne_bytes(), &$span, 16, false);
    // raw
    if let Some(value) = $raw_value.as_ref() {
      $self.convert_string(value, end_position + 4);
    }
    // value
    let value_position = end_position + 8;
    $self.buffer[value_position..value_position + 8].copy_from_slice(&$value_value.to_le_bytes());
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_return_statement {
  ($self:expr, span => $span:expr, argument => [$argument_value:expr, $argument_converter:ident]) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&60u32.to_ne_bytes(), &$span, 8, false);
    // argument
    if let Some(value) = $argument_value.as_ref() {
      $self.update_reference_position(end_position + 4);
      $self.$argument_converter(value);
    }
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_this_expression {
  ($self:expr, span => $span:expr) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(&70u32.to_ne_bytes(), &$span, 4, false);
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_yield_expression {
  ($self:expr, span => $span:expr, delegate => $delegate_value:expr, argument => [$argument_value:expr, $argument_converter:ident]) => {
    let _: &mut AstConverter = $self;
    let end_position = $self.add_type_and_start(
      &78u32.to_ne_bytes(),
      &$span,
      12,
      false,
    );
    // flags
    store_yield_expression_flags!($self, end_position, delegate => $delegate_value);
    // argument
    if let Some(value) = $argument_value.as_ref() {
      $self.update_reference_position(end_position + 8);
      $self.$argument_converter(value);
    }
    // end
    $self.add_end(end_position, &$span);
  };
}

#[macro_export]
macro_rules! store_arrow_function_expression_flags {
  ($self:expr, $end_position:expr, async => $async_value:expr, expression => $expression_value:expr, generator => $generator_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $async_value {
      flags |= 1;
    }
    if $expression_value {
      flags |= 2;
    }
    if $generator_value {
      flags |= 4;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_call_expression_flags {
  ($self:expr, $end_position:expr, optional => $optional_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $optional_value {
      flags |= 1;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_for_of_statement_flags {
  ($self:expr, $end_position:expr, await => $await_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $await_value {
      flags |= 1;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_function_declaration_flags {
  ($self:expr, $end_position:expr, async => $async_value:expr, generator => $generator_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $async_value {
      flags |= 1;
    }
    if $generator_value {
      flags |= 2;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_literal_boolean_flags {
  ($self:expr, $end_position:expr, value => $value_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $value_value {
      flags |= 1;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_member_expression_flags {
  ($self:expr, $end_position:expr, computed => $computed_value:expr, optional => $optional_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $computed_value {
      flags |= 1;
    }
    if $optional_value {
      flags |= 2;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_method_definition_flags {
  ($self:expr, $end_position:expr, static => $static_value:expr, computed => $computed_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $static_value {
      flags |= 1;
    }
    if $computed_value {
      flags |= 2;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_property_flags {
  ($self:expr, $end_position:expr, method => $method_value:expr, shorthand => $shorthand_value:expr, computed => $computed_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $method_value {
      flags |= 1;
    }
    if $shorthand_value {
      flags |= 2;
    }
    if $computed_value {
      flags |= 4;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_property_definition_flags {
  ($self:expr, $end_position:expr, static => $static_value:expr, computed => $computed_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $static_value {
      flags |= 1;
    }
    if $computed_value {
      flags |= 2;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_template_element_flags {
  ($self:expr, $end_position:expr, tail => $tail_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $tail_value {
      flags |= 1;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_update_expression_flags {
  ($self:expr, $end_position:expr, prefix => $prefix_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $prefix_value {
      flags |= 1;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}

#[macro_export]
macro_rules! store_yield_expression_flags {
  ($self:expr, $end_position:expr, delegate => $delegate_value:expr) => {
    let _: &mut AstConverter = $self;
    let _: usize = $end_position;
    let mut flags = 0u32;
    if $delegate_value {
      flags |= 1;
    }
    let flags_position = $end_position + 4;
    $self.buffer[flags_position..flags_position + 4].copy_from_slice(&flags.to_ne_bytes());
  };
}
