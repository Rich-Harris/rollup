// This file is generated by scripts/generate-ast-converters.js.
// Do not edit this file directly.

type ReadString = (start: number, length: number) => string;

export function convertProgram(buffer: ArrayBuffer, readString: ReadString): Program {
	return convertNode(0, new Uint32Array(buffer), readString);
}

function convertNode(position: number, buffer: Uint32Array, readString: ReadString): any {
	const nodeType = buffer[position];
	const converter = nodeConverters[nodeType];
	/* istanbul ignore if: This should never be executed but is a safeguard against faulty buffers */
	if (!converter) {
		console.trace();
		throw new Error(`Unknown node type: ${nodeType}`);
	}
	return converter(position + 1, buffer, readString);
}

/* eslint-disable sort-keys */
const nodeConverters: ((position: number, buffer: Uint32Array, readString: ReadString) => any)[] = [
	function arrayExpression(position, buffer, readString): ArrayExpression {
		const start = buffer[position++];
		const end = buffer[position++];
		const elements = convertNodeList(buffer[position++], buffer, readString);
		return {
			type: 'ArrayExpression',
			start,
			end,
			elements
		};
	},
	function arrayPattern(position, buffer, readString): ArrayPattern {
		const start = buffer[position++];
		const end = buffer[position++];
		const elements = convertNodeList(buffer[position++], buffer, readString);
		return {
			type: 'ArrayPattern',
			start,
			end,
			elements
		};
	},
	function arrowFunctionExpression(position, buffer, readString): ArrowFunctionExpression {
		const start = buffer[position++];
		const end = buffer[position++];
		const annotations = convertAnnotations(buffer[position++], buffer, readString);
		const body = convertNode(buffer[position++], buffer, readString);
		const parameters = convertNodeList(buffer[position++], buffer, readString);
		return {
			type: 'ArrowFunctionExpression',
			start,
			end,
			...(annotations.length > 0 ? { [ANNOTATION_KEY]: annotations } : {}),
			body,
			parameters
		};
	},
	function assignmentExpression(position, buffer, readString): AssignmentExpression {
		const start = buffer[position++];
		const end = buffer[position++];
		const left = convertNode(buffer[position++], buffer, readString);
		const operator = FIXED_STRINGS[buffer[position++]];
		const right = convertNode(buffer[position++], buffer, readString);
		return {
			type: 'AssignmentExpression',
			start,
			end,
			left,
			operator,
			right
		};
	},
	function assignmentPattern(position, buffer, readString): AssignmentPattern {
		const start = buffer[position++];
		const end = buffer[position++];
		const left = convertNode(buffer[position++], buffer, readString);
		const right = convertNode(buffer[position++], buffer, readString);
		return {
			type: 'AssignmentPattern',
			start,
			end,
			left,
			right
		};
	},
	function breakStatement(position, buffer, readString): BreakStatement {
		const start = buffer[position++];
		const end = buffer[position++];
		const labelPosition = buffer[position++];
		const label = labelPosition === 0 ? null : convertNode(labelPosition, buffer, readString);
		return {
			type: 'BreakStatement',
			start,
			end,
			label
		};
	}
];
