#!/usr/bin/env node

import { writeFile } from 'node:fs/promises';
import { AST_NODES } from './ast-types.js';
import { lintFile } from './helpers.js';

const bufferToJsAstFile = new URL('../src/utils/buffer-to-ast.ts', import.meta.url);

const astNodeNamesWithFieldOrder = Object.entries(AST_NODES).map(([name, node]) => ({
	fieldNames: Object.keys(node.fields || {}),
	name
}));

const jsConverters = astNodeNamesWithFieldOrder.map(({ name, fieldNames }) => {
	const node = AST_NODES[name];
	const { fields = {} } = node;
	return `function ${firstLetterLowercase(name)} (position, buffer, readString): ${name} {
    const start = buffer[position++];
    const end = buffer[position++];
    ${fieldNames.map(name => getFieldDefinition(name, fields[name])).join('\n')}
    return {
      type: '${name}',
      start,
      end,
      ${fieldNames.map(name => getFieldProperty(name, fields[name])).join(',\n')}
    };
  }`;
});

/**
 * @param {string} fieldName
 * @param {import('./ast-types.js').FieldType} fieldType
 * @returns {string}
 */
function getFieldDefinition(fieldName, fieldType) {
	switch (fieldType) {
		case 'Node': {
			return `const ${fieldName} = convertNode(buffer[position++], buffer, readString);`;
		}
		case 'OptionalNode': {
			return `const ${fieldName}Position = buffer[position++];\nconst ${fieldName} = ${fieldName}Position === 0 ? null : convertNode(${fieldName}Position, buffer, readString);`;
		}
		case 'NodeList': {
			return `const ${fieldName} = convertNodeList(buffer[position++], buffer, readString);`;
		}
		case 'Annotations': {
			return `const ${fieldName} = convertAnnotations(buffer[position++], buffer, readString);`;
		}
		case 'FixedString': {
			return `const ${fieldName} = FIXED_STRINGS[buffer[position++]];`;
		}
		default: {
			throw new Error(`Unknown field type: ${fieldType}`);
		}
	}
}

/**
 * @param {string} fieldName
 * @param {import('./ast-types.js').FieldType} fieldType
 * @returns {string}
 */
function getFieldProperty(fieldName, fieldType) {
	switch (fieldType) {
		case 'Annotations': {
			return `...(${fieldName}.length > 0 ? { [ANNOTATION_KEY]: ${fieldName} } : {})`;
		}
		default: {
			return fieldName;
		}
	}
}

/**
 * @param {string} string
 * @returns {string}
 */
function firstLetterLowercase(string) {
	return string[0].toLowerCase() + string.slice(1);
}

const bufferToJsAst = `// This file is generated by scripts/generate-ast-converters.js.
// Do not edit this file directly.

type ReadString = (start: number, length: number) => string;

export function convertProgram(buffer: ArrayBuffer, readString: ReadString): Program {
  return convertNode(0, new Uint32Array(buffer), readString);
}

/* eslint-disable sort-keys */
const nodeConverters: ((position: number, buffer: Uint32Array, readString: ReadString) => any)[] = [
  ${jsConverters.join(',\n')}
];

function convertNode(position: number, buffer: Uint32Array, readString: ReadString): any {
  const nodeType = buffer[position];
  const converter = nodeConverters[nodeType];
  /* istanbul ignore if: This should never be executed but is a safeguard against faulty buffers */
  if (!converter) {
    console.trace();
    throw new Error(\`Unknown node type: \${nodeType}\`);
  }
  return converter(position + 1, buffer, readString);
}

function convertNodeList(position: number, buffer: Uint32Array, readString: ReadString): any[] {
  const length = buffer[position++];
  const list: any[] = [];
  for (let index = 0; index < length; index++) {
    const nodePosition = buffer[position++];
    list.push(nodePosition ? convertNode(nodePosition, buffer, readString) : null);
  }
  return list;
}
`;

await writeFile(bufferToJsAstFile, bufferToJsAst);
await lintFile(bufferToJsAstFile);
