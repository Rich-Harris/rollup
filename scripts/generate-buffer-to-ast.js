#!/usr/bin/env node

import { writeFile } from 'node:fs/promises';
import { AST_NODES, astNodeNamesWithFieldOrder } from './ast-types.js';
import { firstLetterLowercase, lintFile } from './helpers.js';

const bufferToJsAstFile = new URL('../src/utils/buffer-to-ast.ts', import.meta.url);

const jsConverters = astNodeNamesWithFieldOrder.map(({ name, fieldNames }) => {
	const node = AST_NODES[name];
	const flagsDefinition = node.flags ? `const flags = buffer[position++];\n` : '';
	const properties = [
		...(node.flags?.map((name, index) => `${name}: (flags & ${1 << index}) === ${1 << index}`) ||
			[]),
		...fieldNames.map(name => getFieldProperty(name, node)),
		...getFixedProperties(node)
	];
	return `function ${firstLetterLowercase(name)} (position, buffer, readString): ${name}Node {
    const start = buffer[position++];
    const end = buffer[position++];
    ${flagsDefinition}${fieldNames.map(name => getFieldDefinition(name, node)).join('\n')}
    return {
      type: '${name}',
      start,
      end,
      ${properties.join(',\n')}
    };
  }`;
});

/**
 * @param {string} fieldName
 * @param {import('./ast-types.js').NodeDescription} node
 * @returns {string}
 */
function getFieldDefinition(fieldName, node) {
	const fieldType = node.fields?.[fieldName];
	const typeCast = node.fieldTypes?.[fieldName];
	const typeCastString = typeCast ? ` as ${typeCast}` : '';
	switch (fieldType) {
		case 'Node': {
			return `const ${fieldName} = convertNode(buffer[position++], buffer, readString)${typeCastString};`;
		}
		case 'OptionalNode': {
			return `const ${fieldName}Position = buffer[position++];\nconst ${fieldName} = ${fieldName}Position === 0 ? null : convertNode(${fieldName}Position, buffer, readString)${typeCastString};`;
		}
		case 'NodeList': {
			return `const ${fieldName} = convertNodeList(buffer[position++], buffer, readString)${typeCastString};`;
		}
		case 'Annotations':
		case 'InvalidAnnotations': {
			return `const ${fieldName} = convertAnnotations(buffer[position++], buffer)${typeCastString};`;
		}
		case 'FixedString': {
			return `const ${fieldName} = FIXED_STRINGS[buffer[position++]]${typeCastString};`;
		}
		default: {
			throw new Error(`Unknown field type: ${fieldType}`);
		}
	}
}

/**
 * @param {string} fieldName
 * @param {import('./ast-types.js').NodeDescription} node
 * @returns {string}
 */
function getFieldProperty(fieldName, node) {
	switch (node.fields?.[fieldName]) {
		case 'Annotations': {
			return `...(${fieldName}.length > 0 ? { [ANNOTATION_KEY]: ${fieldName} } : {})`;
		}
		case 'InvalidAnnotations': {
			return `...(${fieldName}.length > 0 ? { [INVALID_ANNOTATION_KEY]: ${fieldName} } : {})`;
		}
		default: {
			return fieldName;
		}
	}
}

/**
 * @param {import('./ast-types.js').NodeDescription} node
 * @return {string[]}
 */
function getFixedProperties(node) {
	return Object.entries(node.fixed || {}).map(([key, value]) => `${key}: ${JSON.stringify(value)}`);
}

const types = astNodeNamesWithFieldOrder.map(({ name }) => {
	const node = AST_NODES[name];
	let typeDefinition = `type ${name}Node = estree.${name} & AstNode`;
	if (Object.values(node.fields || {}).includes('Annotations')) {
		typeDefinition += ' & { [ANNOTATION_KEY]?: RollupAnnotation[] }';
	}
	if (Object.values(node.fields || {}).includes('InvalidAnnotations')) {
		typeDefinition += ' & { [INVALID_ANNOTATION_KEY]?: RollupAnnotation[] }';
	}
	const fixedProperties = getFixedProperties(node);
	if (fixedProperties.length > 0) {
		typeDefinition += ` & { ${fixedProperties.join(', ')} }`;
	}
	typeDefinition += ';';
	return typeDefinition;
});

const bufferToJsAst = `// This file is generated by scripts/generate-ast-converters.js.
// Do not edit this file directly.

import type * as estree from 'estree';
import type { AstNode } from '../rollup/types';
import { FIXED_STRINGS } from './convert-ast-strings';

export const ANNOTATION_KEY = '_rollupAnnotations';
export const INVALID_ANNOTATION_KEY = '_rollupRemoved';

export function convertProgram(buffer: ArrayBuffer, readString: ReadString): ProgramNode {
  return convertNode(0, new Uint32Array(buffer), readString);
}

/* eslint-disable sort-keys */
const nodeConverters: ((position: number, buffer: Uint32Array, readString: ReadString) => any)[] = [
  ${jsConverters.join(',\n')}
];

type ReadString = (start: number, length: number) => string;
export type AnnotationType = 'pure' | 'noSideEffects';

export interface RollupAnnotation {
  start: number;
  end: number;
  type: AnnotationType;
}

${types.join('\n')}

function convertNode(position: number, buffer: Uint32Array, readString: ReadString): any {
  const nodeType = buffer[position];
  const converter = nodeConverters[nodeType];
  /* istanbul ignore if: This should never be executed but is a safeguard against faulty buffers */
  if (!converter) {
    console.trace();
    throw new Error(\`Unknown node type: \${nodeType}\`);
  }
  return converter(position + 1, buffer, readString);
}

function convertNodeList(position: number, buffer: Uint32Array, readString: ReadString): any[] {
  const length = buffer[position++];
  const list: any[] = [];
  for (let index = 0; index < length; index++) {
    const nodePosition = buffer[position++];
    list.push(nodePosition ? convertNode(nodePosition, buffer, readString) : null);
  }
  return list;
}

const convertAnnotations = (position: number, buffer: Uint32Array): RollupAnnotation[] => {
  const length = buffer[position++];
  const list: any[] = [];
  for (let index = 0; index < length; index++) {
    list.push(convertAnnotation(buffer[position++], buffer));
  }
  return list;
};

const convertAnnotation = (position: number, buffer: Uint32Array): RollupAnnotation => {
  const start = buffer[position++];
  const end = buffer[position++];
  const type = FIXED_STRINGS[buffer[position]] as AnnotationType;
  return { end, start, type };
};
`;

await writeFile(bufferToJsAstFile, bufferToJsAst);
await lintFile(bufferToJsAstFile);
